/**
 * Intelligence Router - The Heart of Synapse's Value
 * Provides AI-powered insights, auto-detected relationships, and proactive intelligence
 * THIS IS THE "AHA MOMENT" - showing value from day 1
 */

import { z } from 'zod';
import { createTRPCRouter, orgProcedure } from '../trpc';
import { getPendingCount, getPendingRequests } from '@/lib/ai/claude-code-analysis';
import { logger } from '@/lib/logger';
import fs from 'fs';
import path from 'path';

const RESULTS_DIR = path.join(process.cwd(), '.claude-analysis', 'results');

/**
 * Get insights from Claude Code analysis results
 */
function getClaudeCodeInsights(): string[] {
  try {
    if (!fs.existsSync(RESULTS_DIR)) {
      return [];
    }

    const files = fs.readdirSync(RESULTS_DIR)
      .filter(f => f.startsWith('insight-') && f.endsWith('.json'))
      .sort()
      .reverse()
      .slice(0, 1); // Get most recent

    if (files.length === 0) return [];

    const latestFile = path.join(RESULTS_DIR, files[0]);
    const results = JSON.parse(fs.readFileSync(latestFile, 'utf8'));

    return results.insights || [];
  } catch (error) {
    logger.error('Error reading Claude Code insights', { error });
    return [];
  }
}

export const intelligenceRouter = createTRPCRouter({
  /**
   * Get real-time intelligence feed
   * Shows what's happening across all tools with AI analysis
   */
  getFeed: orgProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(50).default(20),
        timeRange: z.enum(['today', 'week', 'month']).default('week'),
      })
    )
    .query(async ({ ctx, input }) => {
      const timeRanges = {
        today: 1,
        week: 7,
        month: 30,
      };

      const daysAgo = timeRanges[input.timeRange];
      const since = new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000);

      // Get recent activity across all tools
      const [recentItems, recentThreads, recentActivity, detectedRelationships] = await Promise.all([
        // Recent connected items
        ctx.prisma.connectedItem.findMany({
          where: {
            organizationId: ctx.session.organizationId,
            deletedAt: null,
            createdAt: { gte: since },
          },
          take: input.limit,
          orderBy: { createdAt: 'desc' },
          include: {
            thread: { select: { id: true, title: true, status: true } },
            creator: { select: { id: true, fullName: true, avatarUrl: true } },
          },
        }),

        // Recent threads (including auto-created)
        ctx.prisma.goldenThread.findMany({
          where: {
            organizationId: ctx.session.organizationId,
            deletedAt: null,
            createdAt: { gte: since },
          },
          take: input.limit,
          orderBy: { createdAt: 'desc' },
          include: {
            creator: { select: { id: true, fullName: true, avatarUrl: true } },
            _count: { select: { connectedItems: true } },
          },
        }),

        // Activity feed
        ctx.prisma.activityFeed.findMany({
          where: {
            organizationId: ctx.session.organizationId,
            createdAt: { gte: since },
          },
          take: input.limit,
          orderBy: { createdAt: 'desc' },
          include: {
            actor: { select: { id: true, fullName: true, avatarUrl: true } },
            thread: { select: { id: true, title: true } },
            item: { select: { id: true, title: true, integrationType: true } },
          },
        }),

        // Auto-detected relationships
        ctx.prisma.activityFeed.findMany({
          where: {
            organizationId: ctx.session.organizationId,
            actionType: 'relationship_detected',
            createdAt: { gte: since },
          },
          take: 10,
          orderBy: { createdAt: 'desc' },
        }),
      ]);

      // Get insights from Claude Code analysis results
      const insights = getClaudeCodeInsights();
      const pendingAnalysis = getPendingCount();

      return {
        insights,
        pendingAnalysisCount: pendingAnalysis,
        recentItems,
        recentThreads: recentThreads.map(thread => ({
          ...thread,
          isAutoCreated: thread.tags.includes('auto-detected'),
        })),
        recentActivity,
        detectedRelationships: detectedRelationships.map(rel => ({
          id: rel.id,
          type: rel.metadata as any,
          createdAt: rel.createdAt,
        })),
        stats: {
          itemsThisWeek: recentItems.length,
          threadsThisWeek: recentThreads.length,
          relationshipsDetected: detectedRelationships.length,
        },
      };
    }),

  /**
   * Get work summary (generated by Claude Code analysis)
   */
  getWorkSummary: orgProcedure.query(async ({ ctx }) => {
    const [activeThreads, recentItems] = await Promise.all([
      ctx.prisma.goldenThread.findMany({
        where: {
          organizationId: ctx.session.organizationId,
          status: { in: ['planning', 'in_progress', 'review'] },
          deletedAt: null,
        },
        take: 10,
      }),

      ctx.prisma.connectedItem.findMany({
        where: {
          organizationId: ctx.session.organizationId,
          deletedAt: null,
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          },
        },
        take: 20,
        orderBy: { createdAt: 'desc' },
      }),
    ]);

    if (activeThreads.length === 0 && recentItems.length === 0) {
      return {
        summary: 'No active work yet. Connect your tools and create some GitHub issues to see Claude Code analyze relationships!',
        highlights: [],
      };
    }

    // Simple summary without API calls
    const summary = `Your team has ${activeThreads.length} active thread(s) and ${recentItems.length} new item(s) this week. Ask Claude Code to "generate insights" for deeper analysis.`;

    const highlights = [
      `${activeThreads.length} threads in progress`,
      `${recentItems.length} new items this week`,
      getPendingCount() > 0
        ? `${getPendingCount()} item(s) queued for Claude Code analysis`
        : 'No pending analysis - queue is clear!',
    ];

    return {
      summary,
      highlights,
      lastUpdated: new Date(),
    };
  }),

  /**
   * Get blockers and dependencies
   * "What's blocking your team's progress?"
   */
  getBlockers: orgProcedure.query(async ({ ctx }) => {
    // Get threads that haven't been updated in a while
    const stalledThreads = await ctx.prisma.goldenThread.findMany({
      where: {
        organizationId: ctx.session.organizationId,
        status: { in: ['in_progress', 'review'] },
        deletedAt: null,
        lastActivityAt: {
          lte: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000), // No activity in 5+ days
        },
      },
      take: 10,
      include: {
        connectedItems: {
          where: { deletedAt: null },
          take: 5,
        },
        _count: { select: { connectedItems: true } },
      },
      orderBy: { lastActivityAt: 'asc' },
    });

    // Get detected blocking relationships
    const blockingRelationships = await ctx.prisma.activityFeed.findMany({
      where: {
        organizationId: ctx.session.organizationId,
        actionType: 'relationship_detected',
        metadata: {
          path: ['relationshipType'],
          equals: 'blocks',
        },
      },
      take: 10,
      orderBy: { createdAt: 'desc' },
      include: {
        item: { select: { id: true, title: true, integrationType: true } },
      },
    });

    return {
      stalledThreads: stalledThreads.map((thread) => ({
        id: thread.id,
        title: thread.title,
        status: thread.status,
        daysSinceActivity: Math.floor(
          (Date.now() - thread.lastActivityAt.getTime()) / (24 * 60 * 60 * 1000)
        ),
        connectedItems: thread.connectedItems,
      })),
      blockingRelationships: blockingRelationships.map((rel) => ({
        id: rel.id,
        item: rel.item,
        metadata: rel.metadata,
        createdAt: rel.createdAt,
      })),
    };
  }),

  /**
   * Get relationship graph data
   * Visualize how work items connect
   */
  getRelationshipGraph: orgProcedure
    .input(z.object({ threadId: z.string().uuid().optional() }))
    .query(async ({ ctx, input }) => {
      let items;

      if (input.threadId) {
        // Get items for specific thread
        items = await ctx.prisma.connectedItem.findMany({
          where: {
            threadId: input.threadId,
            deletedAt: null,
          },
        });
      } else {
        // Get recent items across organization
        items = await ctx.prisma.connectedItem.findMany({
          where: {
            organizationId: ctx.session.organizationId,
            deletedAt: null,
            createdAt: {
              gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
            },
          },
          take: 100,
        });
      }

      // Get relationships
      const relationships = await ctx.prisma.activityFeed.findMany({
        where: {
          organizationId: ctx.session.organizationId,
          actionType: 'relationship_detected',
        },
        take: 100,
        orderBy: { createdAt: 'desc' },
      });

      // Build graph data
      const nodes = items.map((item) => ({
        id: item.id,
        type: item.integrationType,
        label: item.title || 'Untitled',
        threadId: item.threadId,
      }));

      const edges = relationships
        .map((rel: any) => {
          const metadata = rel.metadata as any;
          return {
            source: rel.itemId,
            target: metadata.targetItemId,
            type: metadata.relationshipType,
            confidence: metadata.confidence,
          };
        })
        .filter((edge) => {
          // Only include edges where both nodes exist
          return nodes.some(n => n.id === edge.source) && nodes.some(n => n.id === edge.target);
        });

      return {
        nodes,
        edges,
      };
    }),

  /**
   * Get analysis queue status
   */
  getQueueStatus: orgProcedure.query(() => {
    const pending = getPendingRequests();
    const count = getPendingCount();

    return {
      count,
      requests: pending.map(r => ({
        id: r.id,
        type: r.type,
        timestamp: r.timestamp,
      })),
    };
  }),
});
